---
title: csapp datelab详解
date: 2022-04-5 20:31:58
author: 某人不会敲代码
tags: 
- 博客
- 笔记
- csapp datelab
categories: 
- csapp
comments: true
summary: 从入门到入土
cover: C:\Users\a\blog\themes\Butterfly\source\img\csapp.jpg
---

​		环境搭建用了我好久的时间，这个电脑我是真的服气，进入vm卡半天，刚搭建好的Ubuntu又遇到一些问题，直接寄了。没办法，只能再耗费一些时间重新搭建Ubuntu， 结果又因为网卡，下载镜像就下了两天，搭建环境是真滴累。好在是经过一番努力终于将环境搞定，可以开始实验了。

# **1.bitXor**  

​		这道题的目的大致就是用于运算和非运算实现实现异或运算，难度还可以。  逻辑运算有三种基本运算：与、或、非，其他复杂的运算可以用这三种运算实现。

![](C:\Users\a\blog\source\_posts\csapp datelab详解图片\1.png)
		我推了几遍只推出一个公式，也就是return (~x & y)|(x & ~y);大致过程就是先画出真值表，然后推导公式，最后是画逻辑电路图，不过这一步就没必要了。但是这显然不符合题目要求，题目要求只用与和非，所以进一步推导的公式就是return ~(~x & ~y) & ~(x & y);这一公式我是从网上找的。

# **2.tmin**   

![](C:\Users\a\blog\source\_posts\csapp datelab详解图片\2.png)
		题目大致意思就是返回32位二进制补码的最小整数。
		首先要知道位移符的作用，对于一个n位的操作数x，x<<k操作会生成一个值：x向左移动k位，丢弃最高的k位，并在右端补k个0。位移量应该是一个0~n-1之间的值。计算机中的数都是用补码进行表示的，并且最高位是符号位，应用的运算系统是模运算。


<img src="C:\Users\a\blog\source\_posts\csapp datelab详解图片\3.png" style="zoom:80%;" />
		我们可以以这个图位例，使用的是4位二进制数，一共有16个机器数，因为最高位是符号位，所以0111是最大的正数，1000是最小的负数，而在模运算系统中，一个负数的补码等于模减该负数的绝对值，所以1000就是该4位二进制补码的最小整数。因此，对于32位二进制补码来说，最小整数就是0x80000000，1左移31位就得到了答案。

# **3.isTmax**

​		这个题目的大意是：输入的x如股票是最大值就返回1，否则返回0。

![](C:\Users\a\blog\source\_posts\csapp datelab详解图片\4.png)
		我们知道32位二进制数的最大值是0x7FFFFFFF,则x+1就是超出了int的这个范围，因此x与x+1进行比较，x就是最大值，那么返回值就是应该是1。所以我们需要做的就是通过逻辑运算让返回值为1。x+1是0x80000000，取反的话就和原来的最大值相同，又因为两个相同的值进行异或得到的结果为0，所以异或结果再非运算就能得到结果为1，写成式子就是：!(x^~(x+1))。但是这个式子依然不能涵盖所有结果，还有一种特殊情况，那就是x=-1的时候，即x=0xFFFFFFFF，x+1=0x00000000，取反结果和x一样，因此按上述方法运算得到的结果也是1，但实际上x=-1是最小值，输出应该为0，所以我们应该排除-1这种情况，因此使用与运算就是!(x^~(x+1))&!!(x+1),在x+1前面加上两个非，这样就可以避免-1这种特殊情况了。

# **4.ALL0ddBits**  

​		这道题的大致意思就是x的奇数位上如果都是1，则返回1，反之则返回0。

![](C:\Users\a\blog\source\_posts\csapp datelab详解图片\5.png)
		那么关键就是判定奇数位上是否都为1，只要有一个不为1，那么这个数字就不符合要求了，那么判断它是不是1，只需要和1进行与运算就行了，为1则得出1，为0则得出0，因此0xAAAAAAAA恰好符合条件，拿0xAAAAAAAA和x进行与运算，如果x符合条件，那么输出的结果依然是0xAAAAAAAA，然后让结果继续和0xAAAAAAAA进行异或运算，一个值与它自身异或得到的结果为0，最后！0即为1，如果x不符合条件，那么最后输出的结果就是0。最后得到的式子就是：return !((0xAAAAAAAA & x) ^ 0xAAAAAAAA);

# **5.negate**

​		这道题的大致意思就是返回一个值的负数，这绝对是最简单的题，那就短话短说。

![](C:\Users\a\blog\source\_posts\csapp datelab详解图片\6.png)
<img src="C:\Users\a\blog\source\_posts\csapp datelab详解图片\7.png" style="zoom:80%;" />

​		还得是看这张表，数值取反后加1就是对应的负数了。  最后得到的式子为：return ~x + 1 ;

# **6.isAsciiDigit**   

​		这道题也是挺简单的，题目大致意思是输入的x如果大于0x30且小于0x39，则输出1，反之输出0，并且有提示这个范围就是‘0’到‘9’的ASCII码值。
![](C:\Users\a\blog\source\_posts\csapp datelab详解图片\8.png)
​		因为计算机在比较大小的时候，是做减法，两数相减，然后判断结果是否为0，因此我们可以将x与范围边界进行减法，而减法又可以转换为加法，所以就是x + (~48 + 1)和(~x + 1) + 57，48和57是‘0’和‘9’对应的ASCII值，又因为计算机中的数由补码表示，正数的符号位为0，负数的符号位为1，故我们可以将前面两个算式得到的结果进行移位，假设x在范围里面，那么那两个算式的结果移位之后都应该为0，两个结果都加上1，然后进行与运算，就能得到返回值为1，如果x不在范围内，返回值就是0。最后得到的返回式子为return (((x + (~48 + 1))>>31)+1) & ((((~x + 1) + 57)>>31)+1);

# **7.conditional**   

​		这道题的大致意思就是用逻辑运算和取反、位移等实现x ? y : z。
![](C:\Users\a\blog\source\_posts\csapp datelab详解图片\9.png)
​		这道题的wp不太好写，我也只能讲一个大概。  
​		至于x ? y : z的原理就是: 
​			（1）判断x的真假；                     
​			（2）如果x为真，那么就输出y；                     
​			（3）如果x为假，那么输出z。  
​		那么这道题也就很好理解了，思路首先就是判断x的真假，然后选择输出y还是z。判断x真假很好办，两次“非”运算就能得出真假。之后，将上一步结果取反加1，也就是换算成结果的负数，如果结果为1（真），那么转换成-1，再与y进行与运算，就可以保留y。然后就是z，z与第一步结果的取反进行与运算，如果第一步结果为1，那么取反之后就是0，这样就可以消掉z。最后总结，x为真：保留y、消掉z；x为假：消掉y，保留z。   根据上述描述得到的式子：return ((~A + 1) & y) + (~(~A + 1) & z);

# **8.isLessOrEqual**  

​		这道题的大致意思就是使用基本运算实现“x<=y”，还是有一定难度的。
![](C:\Users\a\blog\source\_posts\csapp datelab详解图片\10.png)
​		计算机在比较两个数的大小的时候会先进行减法运算，然后判断正负，所以我们可以按照这个思路来解题，但是用减法的话需要考虑溢出，所以首先判断两个数的符号，c1是x+，y-，c2是x-,y+。因为我们是用y减x，所以当c1为真且d为假的时候就发生了溢出，这时候计算得到的结果就与实际情况相反，所以要避免。在c2成立的时候，因为是负数和正数进行比较，所以整个运算就直接成立。  最后得到的返回运算式就是return (!d & !c1) | c2;
**9.logicalNeg**  
​		这道题的大致意思就是实现非运算（!），还是很有难度的。
![](C:\Users\a\blog\source\_posts\csapp datelab详解图片\11.png)
​		非运算就是非0为1，非1为0，除了0这种特殊情况，其它数取反加1都是原来的数的相反数，相反数与原来的数进行位或运算得到的结果符号位都为1，然后再进行位移31位再加1，得到的结果就是0。对于0来说，取反加1再位或得到的结果仍然为0，右移31位再加1就是1。
**10.howManyBits**   
​		这道题的大致意思就是一个数的补码最少可以用多少位来表示。比如12，二进制形式0x1100，再加上一位符号位，就是5位，再看0，用二进制表示就是0x0，只有一位，-1用二进制表示，是1，也只有一位。
![](C:\Users\a\blog\source\_posts\csapp datelab详解图片\12.png)
​		这道题我自己做是没有任何思路，看着别人的wp我才能搞懂。  大致分为3种情况：0、-1和其它数。  0只用一个符号位就能够表示，-1和0一样，-1的二进制补码是全1，取反之后就是0，所以也能用一个符号位表示。  我们主要考虑一般的数，一般的数取反之后和取反之前都可以用相同的符号位进行表示。  对于传输进去的负数，进行取反，正数就不用管。  然后是判断高16位有没有1，接着判断8位，然后是4位、2位、1位。

# **11.floatScale2**   

​		这道题是求浮点数乘以2。
 ![](C:\Users\a\blog\source\_posts\csapp datelab详解图片\13.png)
​		对于一般的浮点数乘以二来说，是阶码加一，因为不同类型的数相乘是转化成同一种类型的，浮点数相乘是尾数相乘除、阶码相加减，2的阶码是1，尾数为0。
​		因此我们只需要考虑特殊情况就可以了：
  	   （1）0乘以2
​     	（2）无穷大或NaN（非数）乘以2；    
​	 	（3)非规格化数乘以2；   
​		我们看上述的代码，首先提取出阶码部分和尾数部分，然后再判断uf是否为0或无穷大或NaN或非规格化数，如果uf为无穷大或NaN就直接返回，乘以二之后依旧是原数。为0和非规格化数时，尾数只需左移一位，0左移还是0，非规格化数左移一位后阶码加1，变成了规格化数。

# **12.floatFloat2Int**  

​		这道题是将浮点数转化成整形。
 ![](C:\Users\a\blog\source\_posts\csapp datelab详解图片\14.png)
​		将浮点型转化为整形，会舍去小数，但是浮点型所表示的范围要比整形所表示的范围大，所以某些浮点型的值超过了整形所能表示的范围，根据题目要求，就需要返回0x80000000了，并且当浮点型小于1时，转化成整形就是0。和上一道题目类似，首先提取出阶码和尾数，并且还要判断uf的符号位。如果阶码超过整形所能返回的最大值，则返回题目所要求的数值，如果阶码小于127，也就是uf小于1，则返回0。如果是一般范围内的浮点数，则去掉小数转换成整形。

# **13.floatPower2**  

​		这道题是求2的x次方，并以浮点数的形式输出。
![](C:\Users\a\blog\source\_posts\csapp datelab详解图片\15.png)
​		这个很好理解，阶码的范围就是-126~127，小于-126返回0，大于127返回无穷大，如果是正确范围内的，则返回x加上偏移量后再左移23位，得到这个以浮点数形式输出的2的x次方。

  最后附上测试表：
![](C:\Users\a\blog\source\_posts\csapp datelab详解图片\16.png)
		我的csapp 实验一的旅程到此就结束了，我最深的感触就是这门学科真的很有难度，但是也带给我很大的精神愉悦，特别是在做实验的时候，每做出一道题并且通过测试之后，我真的很开心，比我打一把游戏胜利之后都要开心，因为我确实是看到了自己的进步。但是它也使我认识到了和别人的差距，不努力是真的不行，和别人的差距只会越来越大。并且，这次实验我的理解还不够深，特别是最后四道题，我看着别人写的wp一步一步来的，学的不精是我的问题，以后更是不能放弃，学得更多之后，还要回过头来再把这个实验刷几遍，必须学得透彻之后我才能走的更远。
		以后会持续更新csapp的，还有更多的实验等着我呢！
